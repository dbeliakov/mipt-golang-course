# JSON censor

JSON-сообщения в Go обычно представляются в виде слайса байт. 
По каким-то причинам, мы не хотим, чтобы те или иные подстроки оказывались в `json`. Необходимо пройтись по всем строковым значениям в `json`, и если в значении содержится заданная подстрока, его нужно заменить на `"***"` и вернуть измененную последовательность байт:
```go
input := []byte(`{"k": "v", "another_key": {"arr": ["word_to_censor"],
"inner_key": "what if i have a word_to_censor here???"}}`)
wordToCensor := "word_to_censor"

res, _ := CensorJSON(input, wordToCensor)
fmt.Println(string(res))
// {"k": "v", "another_key": {"arr": ["***"], "inner_key": "***"}} -- заменяется не только сама подстрока, а все строковое значение
```

Подобную задачу, возможно, можно решить с помощью регулярных выражений или ручного парсинга JSON-сообщения, но скорее всего это приведет к невероятно переусложненному коду. 
Для решения этой задачи можно вспомнить, что могут представлять собой JSON-значения:
- Числа - `int` и `double`
- Строки - `string`
- Массивы произвольных JSON-значений - `[]any`
- Наборы пар ключ-значение, где ключи являются строками - `map[string]any`

Для каждого из значений понятно, что с ним нужно делать - не трогать числа, заменять строки, итерироваться по массивам и рекурсивно заменять строки в их элементах, итерироваться по парам ключ-значение и рекурсивно заменять строки в значениях.

Получается, что если мы получим какой-то тип, который позволит проверять, что конкретно в нем лежит. 
Очень удобно, что интерфейсы в Go как раз обладают таким свойством (в частности `interface{}`) с помощью [type switch](https://go.dev/tour/methods/16).

Также удобно, что JSON-сообщения можно парсить и сохранять в переменные с типом `interface{}`:
```go
var val interface{}
err := json.Unmarshal(jsonMessage, &val)
```

Всех этих данных должно хватить, чтобы написать функцию `CensorJSON`.

Вам могут пригодиться:
- [json.Unmarshal](https://pkg.go.dev/encoding/json#Unmarshal)
- [json.Marshal](https://pkg.go.dev/encoding/json#Marshal)
